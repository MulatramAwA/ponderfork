import os
from json import dumps
from io import BytesIO
from zipfile import ZipFile

from ..utils import logger
from ..ponder import Ponder
from .compiler import compile_operations


def compile_datapack(
        ponder: Ponder,
        version: bool = True,
        pos_offset: tuple = (0, 0, 0),
        ponder_name: str = "ponders",
        output_dir: str = "."
):
    """
    编译思索对象为Minecraft数据包
    :param ponder: 你的思索对象
    :param version: 是否为1.21+版本
    :param ponder_name: 你的思索名称
    :param pos_offset: 偏移坐标
    :param output_dir: 输出目录
    :return: 输出路径
    """
    logger.info(f"正在编译思索为数据包...")
    logger.debug(
        f"传入参数: version={version}, pos_offset={pos_offset}, ponder_name={ponder_name}, output_dir={output_dir}")

    if not os.path.exists(f'{output_dir}/'):
        os.mkdir(f'{output_dir}/')

    # 检测输出的zip文件是否存在
    if os.path.exists(f'{output_dir}/{ponder_name}.zip'):
        logger.warning(f"输出文件 {ponder_name}.zip 已存在, 可能覆盖已有文件, 是否继续? (y/n)")
        if input().strip().lower() != "y":
            logger.info(f"已取消编译.")
            return

    datapack_content = {}
    commands = compile_operations(ponder, pos_offset)

    # 生成pack.mcmeta
    meta_data = {
        "pack": {
            "pack_format": 16,
            "supported_formats": [16, 39],
            "description": "使用 creepe_ponder 生成的思索数据包"
        }
    }
    datapack_content['pack.mcmeta'] = dumps(meta_data)

    # 生成用于存放函数的文件夹
    function_base_directory = 'function/' if version else 'functions/'

    functions = {}  # 存放函数的列表
    # 整理每个时刻工作的指令
    for command in commands:
        time, command_string = command
        if time in functions:
            functions[time].append(command_string)
            continue
        functions[time] = ['# Generated by creepe_ponder', command_string]

    # 生成对应的文件内容

    for time, command_list in functions.items():
        datapack_content[f'{function_base_directory}/_{time}.mcfunction'] = '\n'.join(command_list)

    # 生成主函数文件
    command_list = ['# Generated by creepe_ponder']

    # 使用/schedule指令让函数文件按顺序执行
    for time in functions.keys():
        command_list.append(f"schedule function {ponder_name}:_{time} {time * 2 + 1} append")  # rt转为gt, 并增加一个偏移量

    datapack_content[f'{function_base_directory}/main.mcfunction'] = '\n'.join(command_list)

    # 生成数据包
    datapack = BytesIO()
    with ZipFile(datapack, 'w') as zip_file:
        for file_name, file_content in datapack_content.items():
            zip_file.writestr(file_name, file_content)

    # 写入文件
    with open(f'{output_dir}/{ponder_name}.zip', 'wb') as file:
        file.write(datapack.getvalue())

    logger.info(f"编译完毕！共在 {len(functions)} 个时刻输出 {len(commands)} 条指令，"
                f"总动画长度：{max(functions.keys()) / 20} 秒, 输出路径: {output_dir}/{ponder_name}.zip")
